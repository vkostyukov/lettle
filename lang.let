// This is the draft version of 'lang.let' file - a standard Lettle library.
// This is tiny piece of awesome code that powers user programs.

// Starting with very base things like 'Unit', which is actually 'void'.
// We are defining it as am empty tuple. Awesome!
tuple Unit

// We also want some tuples.
tuple Tuple[A, B](1: A, 2: B)
tuple Tuple[A, B, C](1: A, 2: B, 3: C)
tuple Tuple[A, B, C, D](1: A, 2: B, 3: C, 4: D)
tuple Tuple[A, B, C, D](1: A, 2: B, 3: C, 4: D)
tuple Tuple[A, B, C, D, E](1: A, 2: B, 3: C, 4: D, 5: E)
tuple Tuple[A, B, C, D, E, F](1: A, 2: B, 3: C, 4: D, 5: E, 6: F)

// How about just having an friendly aliases for tuples? Here we go.
alias Pair[A, B] = Tuple[A, B]
alias Triple[A, B, C] = Tuple[A, B, C]

// A disjoint option in one line of code.
union Option[A] = Some of A ? None

// And the last thing - singly-linked list.
union List[A] = Cons of A * List[A] ? Nil

// Now we want to have some usefull functions for working with lists.

// Takes the head of given list.
let head[A](ls: List[A]) = ls 
  ? Cons(hd, _) -> hd
  ! fail "An empty list."

// Takes the tail of given list.
let tail[A](ls: List[A]) = ls
  ? Cons(_, tl) -> tl
  ! fail "An empty list."

// Checks whether the given list is empty of not.
let empty[A](ls: List[A]) = ls
  ? Nil -> true
  ! false

// A cons operaion (prepend).
let cons[A](x: A, ls: List[A]) = Cons(x, ls)

// A snoc operation (append).
let snoc[A](x: A, ls: List[A]) = ls
  ? Cons(hd, tl) -> Cons(hd, x | snoc tl)
  ! Cons(x, Nil)

// Takes first 'n' elements from given list.
let take[A](ls: List[A], n: Int) =
  if (n == 0) Nil
  else head ls | cons take(tail ls, n - 1)

// Maps each element of given list to function.
let map[A, B](ls: List[A], fn: A -> B) = ls
  ? Cons(hd, tl) -> fn hd | cons map(tl, fn)
  ! Nil

//let fold[A](ls: List[A], fn: A * A -> A) = 
//  if (emtpy ls) fail "An empty list."
//  else loop(ls)
//let fold::loop[A](ls: List[A]) ls
//  ? Cons(hd, Nil) -> hd
//  ? Cons(first, Cons(second, tl)) -> fn(first, second) fold(tl, fn)

// Filters given list.
let filter[A](ls: List[A], fn: A -> Boolean) = ls
  ? Cons(hd, tl) when (fn(hd)) -> hd | cons filter(tl, fn)
  ? Cons(_, tl) -> filter(tl, fn)
  ! Nil

// Some smart constructors for List

let List = Nil
let List[A](x1: A) = Cons(x1, List)
let List[A](x1: A, x2: A) = Cons(x1, List(x2))
let List[A](x1: A, x2: A, x3: A) = Cons(x1, List(x2, x3))
let List[A](x1: A, x2: A, x3: A, x4: A) = Cons(x1, List(x2, x3, x4))
let List[A](x1: A, x2: A, x3: A, x4: A, x5: A) = Cons(x1, List(x2, x3, x4, x5))
let List[A](x1: A, x2: A, x3: A, x4: A, x5: A, x6: A) = Cons(x1, List(x2, x3, x4, x5, x6))
let List[A](x1: A, x2: A, x3: A, x4: A, x5: A, x6: A, x7: A) = Cons(x1, List(x2, x3, x4, x5, x6, x7))
let List[A](x1: A, x2: A, x3: A, x4: A, x5: A, x6: A, x7: A, x8: A) = Cons(x1, List(x2, x3, x4, x5, x6, x7, x8))
let List[A](x1: A, x2: A, x3: A, x4: A, x5: A, x6: A, x7: A, x8: A, x9: A) = Cons(x1, List(x2, x3, x4, x5, x6, x7, x8, x9))
let List[A](x1: A, x2: A, x3: A, x4: A, x5: A, x6: A, x7: A, x8: A, x9: A, x10: A) = Cons(x1, List(x2, x3, x4, x5, x6, x7, x8, x9, x10))

// We would like to have a Range type
tuple Range(from: Int, to: Int)

let head(r: Range) = r 
  ? Range(from, to) when (from <= to) -> from
  ! fail "An empty range."

let tail(r: Range) = r 
  ? Range(from, to) when (from <= to) -> Range(from + 1, to)
  ! fail "An empty range."

let empty(r: Range) = r | Range(from, to) -> from > to

let take(r: Range, n: Int) = r
  ? Range(from, to) when (from + n <= to) -> Range(from, from + n)
  ! fail "An empty range."

let map[A](r: Range, fn: Int -> A) = r | Range(from, to) -> loop(from)
let map::loop(from: Int) = 
  if (from > to) Nil
  else fn from | cons loop(from + 1)

let fold = ???

let filter(r: Range, fn: Int -> Boolean) = r | Range(from, to) -> loop(from)
let filter::loop(from: Int) = 
  if (from > to) Nil
  else if (fn from) from | cons loop(from + 1)
  else loop(from + 1)

// Some of type conversions

let Int(s: String) = `Integer.valueOf(s)` as Int
let Real(s: String) = `Double.valueOf(s)` as Real
let Bollean(s: String) = `Boolean.valueOf(s)` as Boolean

let String(i: Int) = `String.valueOf(i)` as String
let String(r: Real) = `String.valueOf(r)` as String
let String(b: Boolean) = `String.valueOf(b)` as String

// This allow as :
// Range(1, 100) | List  <- converts to list
let List(r: Range) = r | Range(from, to) -> loop(from)
// 'to' alaliable here via dynamic context
let List::loop(from: Int) = 
  if (from > to) Nil
  else from | cons loop(from + 1)

// Some Math staff

let min[#A](x: A, y: A) = if (x < y) x else y
let max[#A](x: A, y: A) = if (x > y) x else y

let abs(x: Int) = if (x > 0) x else -x
let abs(x: Real) = if (x > 0.0) x else -x

let sqrt(x: Real) = `Math.sqrt(x)` as Real

// Some usefull functions

let ??? = fail "Not implemented yet! Be patient!"
let println(s: String) = `System.out.println(s)` as Unit
